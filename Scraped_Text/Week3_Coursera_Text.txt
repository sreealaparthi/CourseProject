This lecture is about Evaluation of Text Retrieval Systems In the previous lectures, we have talked about the a number of Text Retrieval Methods, different kinds of ranking functions. But how do we know which one works the best? In order to answer this question, we have to compare them and that means we have to evaluate these retrieval methods. So this is the main topic of this lecture. First, lets think about why do we have to do evaluation? I already give one reason. That is, we have to use evaluation to figure out which retrieval method works better. Now this is very important for advancing our knowledge. Otherwise, we wouldn't know whether a new idea works better than an old idea. In the beginning of this course, we talked about the problem of text retrieval. We compare it with data base retrieval. There we mentioned that text retrieval is an empirically defined problem. So evaluation must rely on users. Which system works better, would have to be judged by our users. So, this becomes a very challenging problem because how can we get users involved in the evaluation? How can we do a fair comparison of different method? So just go back to the reasons for evaluation. I listed two reasons here. The second reason, is basically what I just said, but there is also another reason which is to assess the actual utility of a Text Regional system. Imagine you're building your own such annual applications, it would be interesting knowing how well your search engine works for your users. So in this case, matches must reflect the utility to the actual users in real occasion. And typically, this has to be done by using user starters and using the real search engine. In the second case, or the second reason, the measures actually all need to collated with the utility to actually use this. Thus, they don't have to accurately reflect the exact utility to users. So the measure only needs to be good enough to tell which method works better. And this is usually done through a test collection. And this is the main idea that we'll be talking about in this course. This has been very important for comparing different algorithms and for improving search engine system in general. So let's talk about what to measure. There are many aspects of searching that we can measure, we can evaluate. And here, I listed the three major aspects. One, is effectiveness or accuracy. How accurate are the search results? In this case, we're measuring a system's capability of ranking relevant documents on top of non relevant ones. The second, is efficiency. How quickly can you get the results? How much computing resources are needed to answer a query? In this case, we need to measure the space and time overhead of the system. The third aspect is usability. Basically the question is, how useful is a system for new user tasks. Here, obviously, interfaces and many other things also important and would typically have to do user studies. Now in this course, we're going to talk mostly about effectiveness and accuracy measures. Because the efficiency and usability dimensions are not really unique to search engines. And so they are needed for without any other software systems. And there is also good coverage of such and other causes. But how to evaluate search engine's quality or accuracy is something unique to text retrieval and we're going to talk a lot about this. The main idea that people have proposed before using a test set to evaluate the text retrieval algorithm is called the Cranfield Evaluation Methodology. This one actually was developed a long time ago, developed in 1960s. It's a methodology for laboratory test of system components. Its sampling methodology that has been very useful, not just for search engine evaluation. But also for evaluating virtually all kinds of empirical tasks, and for example in natural language processing or in other fields where the problem is empirical to find, we typically would need to use such a methodology. And today with the big data challenging with the use of machine learning everywhere. This methodology has been very popular, but it was first developed for a search engine application in the 1960s. So the basic idea of this approach is to build a reusable test collection and define measures. Once such a test collection is built, it can be used again and again to test different algorithms. And we're going to define measures that allow you to quantify performance of a system and algorithm. So how exactly will this work? Well we can do have a sample collection of documents and this is adjusted to simulate the real document collection in the search application. We're going to also have a sample set of queries, or topics. This is a little simulator that uses queries. Then, we'll have to have those relevance judgments. These are judgments of which documents should be returned for which queries. Ideally, they have to be made by users who formulated the queries. Because those are the people that know exactly what documents would be used for. And finally, we have to have matches for quantify how well our system's result matches the ideal ranked list. That would be constructed base on user's relevance judgements. So this methodology is very useful for starting retrieval algorithms, because the test can be reused many times. And it will also provide a fair comparison for all the methods. We have the same criteria or same dataset to be used to compare different algorithms. This allows us to compare a new algorithm with an old algorithm that was divided many years ago, by using the same standard. So this is the illustration of this works, so as I said, we need our queries that are showing here. We have Q1, Q2 etc. We also need the documents and that's called the document caching and on the right side you will see we need relevance judgments. These are basically the binary judgments of documents with respect to a query. So for example, D1 is judged as being relevant to Q1, D2 is judged as being relevant as well, and D3 is judged as not relevant. And the Q1 etc. These will be created by users. Once we have these, and we basically have a test collection. And then if you have two systems, you want to compare them, then you can just run each system on these queries and the documents and each system would then return results. Let's say if the queries Q1 and then we would have the results here. Here I show R sub A as the results from system A. So this is, remember we talked about task of computing approximation of the relevant document set. R sub A is system A's approximation here. And R sub B is system B's approximation of relevant documents. Now, let's take a look at these results. So which is better? Now imagine if a user, which one would you like? Now let's take a look at the both results. And there are some differences and there are some documents that are returned by both systems. But if you look at the results, you will feel that maybe A is better in the sense that we don't have many number element documents. And among the three documents returned, the two of them are relevant. So that's good, it's precise. On the other hand one council say maybe B is better, because we've got all of them in the documents. We've got three instead of two. So which one is better and how do we quantify this? Well, obviously this question highly depends on a user's task. It depends on users as well. You might even imagine for some users may be system A is better. If the user is not interested in getting all the random documents. Right, in this case the user doesn't have to read a million users will see most of the relevant documents. On the other hand, one can also imagine the user might need to have as many random documents as possible. For example, if you're doing a literature survey you might be in the sigma category, and you might find that system B is better. So in the case, we will have to also define measures that will quantify them. And we might need it to define multiple measures because users have different perspectives of looking at the results.
This lecture is about the basic measures for evaluation of text retrieval systems. In this lecture, we're going to discuss how we design basic measures to quantitatively compare two retrieval systems. This is a slide that you have seen earlier in the lecture where we talked about the Granville evaluation methodology. We can have a test faction that consists of queries, documents, and [INAUDIBLE]. We can then run two systems on these data sets to contradict the evaluator. Their performance. And we raise the question, about which set of results is better. Is system A better or is system B better? So let's now talk about how to accurately quantify their performance. Suppose we have a total of 10 relevant documents in the collection for this query. Now, the relevant judgments show on the right in [INAUDIBLE] obviously. And we have only seen 3 [INAUDIBLE] there, [INAUDIBLE] documents there. But, we can imagine there are other Random documents in judging for this query. So now, intuitively, we thought that system A is better because it did not have much noise. And in particular we have seen that among the three results, two of them are relevant but in system B, we have five results and only three of them are relevant. So intuitively it looks like system A is more accurate. And this infusion can be captured by a matching holder position, where we simply compute to what extent all the retrieval results are relevant. If you have 100% position, that would mean that all the retrieval documents are relevant. So in this case system A has a position of two out of three System B has some sweet hold of 5 and this shows that system A is better frequency. But we also talked about System B might be prefered by some other units would like to retrieve as many random documents as possible. So in that case we'll have to compare the number of relevant documents that they retrieve and there's another method called recall. This method uses the completeness of coverage of random documents In your retrieval result. So we just assume that there are ten relevant documents in the collection. And here we've got two of them, in system A. So the recall is 2 out of 10. Whereas System B has called a 3, so it's a 3 out of 10. Now we can see by recall system B is better. And these two measures turn out to be the very basic of measures for evaluating search engine. And they are very important because they are also widely used in many other test evaluation problems. For example, if you look at the applications of machine learning, you tend to see precision recall numbers being reported and for all kinds of tasks. Okay so, now let's define these two measures more precisely. And these measures are to evaluate a set of retrieved documents, so that means we are considering that approximation of the set of relevant documents. We can distinguish 4 cases depending on the situation of the documents. A document can be retrieved or not retrieved, right? Because we are talking about a set of results. A document can be also relevant or not relevant depending on whether the user thinks this is a useful document. So we can now have counts of documents in. Each of the four categories again have a represent the number of documents that have been retrieved and relevant. B for documents that are not retrieved but rather etc. No with this table then we can define precision. As the ratio of the relevant retrieved documents A to the total of relevant retrieved documents. So, this is just A divided by The sum of a and c. The sum of this column. Singularly recall is defined by dividing a by the sum of a and b. So that's again to divide a by. The sum of the row instead of the column. All right, so we can see precision and recall is all focused on looking at the a, that's the number of retrieved relevant documents. But we're going to use different denominators. Okay, so what would be an ideal result. Well, you can easily see being the ideal case would have precision and recall oil to be 1.0. That means We have got 1% of all the Relevant documents in our results, and all of the results that we returned all Relevant. At least there's no single Not Relevant document returned. In reality, however, high recall tends to be associated with low precision. And you can imagine why that's the case. As you go down the to try to get as many random documents as possible, you tend to encounter a lot of documents, so the precision has to go down. Note that this set can also be defined by a cut off. In the rest of this, that's why although these two measures are defined for retrieve the documents, they are actually very useful for evaluating a rank list. They are the fundamental measures in task retrieval and many other tasks. We often are interested in The precision at ten documents for web search. This means we look at how many documents among the top ten results are actually relevant. Now, this is a very meaningful measure, because it tells us how many relevant documents a user can expect to see On the first page of where they typically show ten results. So precision and recall are the basic matches and we need to use them to further evaluate a search engine, but they are the Building blocks. We just said that there tends to be a trailoff between precision and recall, so naturally it would be interesting to combine them. And here's one method that's often used, called F-measure And it's a [INAUDIBLE] mean of precision and recall as defined on this slide. So, you can see at first, compute the. Inverse of R and P here, and then it would interpret the 2 by using coefficients depending on parameter beta. And after some transformation you can easily see it would be of this form. And in any case it just becomes an agent of precision and recall, and beta is a parameter, that's often set to 1. It can control the emphasis on precision or recall always set beta to 1 We end up having a special case of F-Measure, often called F1. This is a popular measure that's often used as a combined precision and recall. And the formula looks very simple. It's just this, here. Now it's easy to see that if you have a Larger precision, or larger recall than f measure would be high. But, what's interesting is that the trade off between precision and recall is captured an interesting way in f1. So, in order to understand that, we can first look at the natural Why not just the combining and using the symbol arithmetically as efficient here? That would be likely the most natural way of combining them So what do you think? If you want to think more, you can pause the video. So why is this not as good as F1? Or what's the problem with this? Now, if you think about the arithmetic mean, you can see this is the sum of multiple terms. In this case, it's the sum of precision and recall. In the case of a sum, the total value tends to be dominated by the large values. that means if you have a very high P or very high R then you really don't care about whether the other value is low so the whole sum would be high. Now this is not desirable because one can easily have a perfect recall. We have perfect recall easily. Can we imagine how? It's probably very easy to imagine that we simply retrieve all the documents in the collection and then we have a perfect recall. And this will give us 0.5 as the average. But such results are clearly not very useful for the users even though the average using this formula would be relevantly high. In contrast you can see F 1 would reward a case where precision and recall are roughly That seminar, so it would a case where you had extremely high value for one of them. So this means f one encodes a different trade off between that. Now this example shows actually a very important. Methodology here. But when you try to solve a problem you might naturally think of one solution, let's say in this it's this error mechanism. But it's important not to settle on this source. It's important to think whether you have other ways to combine that. And once you think about the multiple variance It's important to analyze their difference, and then think about which one makes more sense. In this case, if you think more carefully, you will think that F1 probably makes more sense. Than the simple. Although in other cases there may be different results. But in this case the seems not reasonable. But if you don't pay attention to these subtle differences you might just take a easy way to combine them and then go ahead with it. And here later, you will find that, the measure doesn't seem to work well. All right. So this methodology is actually very important in general, in solving problems. Try to think about the best solution. Try to understand the problem very well, and then know why you needed this measure, and why you need to combine precision and recall. And then use that to guide you in finding a good way to solve the problem. To summarize, we talked about precision which addresses the question are there retrievable results all relevant? We also talk about the Recall. Which addresses the question, have all of the relevant documents been retrieved. These two, are the two, basic matches in text and retrieval in. They are used for many other tasks, as well. We talk about F measure as a way to combine Precision Precision and recall. We also talked about the tradeoff between precision and recall. And this turns out to depend on the user's search tasks and we'll discuss this point more in a later lecture.
This lecture is about, how we can evaluate a ranked list? In this lecture, we will continue the discussion of evaluation. In particular, we are going to look at, how we can evaluate a ranked list of results. In the previous lecture, we talked about, precision-recall. These are the two basic measures for, quantitatively measuring the performance of a search result. But, as we talked about, ranking, before, we framed that the text of retrieval problem, as a ranking problem. So, we also need to evaluate the, the quality of a ranked list. How can we use precision-recall to evaluate, a ranked list? Well, naturally, we have to look after the precision-recall at different, cut-offs. Because in the end, the approximation of relevant documents, set, given by a ranked list, is determined by where the user stops browsing. Right? If we assume the user, securely browses, the list of results, the user would, stop at some point, and that point would determine the set. And then, that's the most important, cut-off, that we have to consider, when we compute the precision-recall. Without knowing where exactly user would stop, then we have to consider, all the positions where the user could stop. So, let's look at these positions. Look at this slide, and then, let's look at the, what if the user stops at the, the first document? What's the precision-recall at this point? What do you think? Well, it's easy to see, that this document is So, the precision is one out of one. We have, got one document, and that's relevent. What about the recall? Well, note that, we're assuming that, there are ten relevant documents, for this query in the collection, so, it's one out of ten. What if the user stops at the second position? Top two. Well, the precision is the same, 100%, two out of two. And, the record is two out of ten. What if the user stops at the third position? Well, this is interesting, because in this case, we have not got any, additional relevant document, so, the record does not change. But the precision is lower, because we've got number [INAUDIBLE] so, what's exactly the precision? Well, it's two out of three, right? And, recall is the same, two out of ten. So, when would see another point, where the recall would be different? Now, if you look down the list, well, it won't happen until, we have, seeing another relevant document. In this case D5, at that point, the, the recall is increased through three out of ten, and, the precision is three out of five. So, you can see, if we keep doing this, we can also get to D8. And then, we will have a precision of four out of eight, because there are eight documents, and four of them are relevant. And, the recall is a four out of ten. Now, when can we get, a recall of five out of ten? Well, in this list, we don't have it, so, we have to go down on the list. We don't know, where it is? But, as convenience, we often assume that, the precision is zero, at all the, the othe, the precision are zero at all the other levels of recall, that are beyond the search results. So, of course, this is a pessimistic assumption, the actual position would be higher, but we make, make this assumption, in order to, have an easy way to, compute another measure called Average Precision, that we will discuss later. Now, I should also say, now, here you see, we make these assumptions that are clearly not, accurate. But, this is okay, for the purpose of comparing to, text methods. And, this is for the relative comparison, so, it's okay, if the actual measure, or actual, actual number deviates a little bit, from the true number. As long as the deviation, is not biased toward any particular retrieval method, we are okay. We can still, accurately tell which method works better. And, this is important point, to keep in mind. When you compare different algorithms, the key's to avoid any bias toward each method. And, as long as, you can avoid that. It's okay, for you to do transformation of these measures anyway, so, you can preserve the order. Okay, so, we'll just talk about, we can get a lot of precision-recall numbers at different positions. So, now, you can imagine, we can plot a curve. And, this just shows on the, x-axis, we show the recalls. And, on the y-axis, we show the precision. So, the precision line was marked as .1, .2, .3, and, 1.0. Right? So, this is, the different, levels of recall. And,, the y-axis also has, different amounts, that's for precision. So, we plot the, these, precision-recall numbers, that we have got, as points on this picture. Now, we can further, and link these points to form a curve. As you'll see, we assumed all the other, precision as the high-level recalls, be zero. And, that's why, they are down here, so, they are all zero. And this, the actual curve probably will be something like this, but, as we just discussed, it, it doesn't matter that much, for comparing two methods. because this would be, underestimated, for all the method. Okay, so, now that we, have this precision-recall curve, how can we compare ranked to back list? All right, so, that means, we have to compare two PR curves. And here, we show, two cases. Where system A is showing red, system B is showing blue, there's crosses. All right, so, which one is better? I hope you can see, where system A is clearly better. Why? Because, for the same level of recall, see same level of recall here, and you can see, the precision point by system A is better, system B. So, there's no question. In here, you can imagine, what does the code look like, for ideal search system? Well, it has to have perfect, precision at all the recall points, so, it has to be this line. That would be the ideal system. In general, the higher the curve is, the better, right? The problem is that, we might see a case like this. This actually happens often. Like, the two curves cross each other. Now, in this case, which one is better? What do you think? Now, this is a real problem, that you actually, might have face. Suppose, you build a search engine, and you have a old algorithm, that's shown here in blue, or system B. And, you have come up with a new idea. And, you test it. And, the results are shown in red, curve A. Now, your question is, is your new method better than the old method? Or more, practically, do you have to replace the algorithm that you're already using, your, in your search engine, with another, new algorithm? So, should we use system, method A, to replace method B? This is going to be a real decision, that you to have to make. If you make the replacement, the search engine would behave like system A here, whereas, if you don't do that, it will be like a system B. So, what do you do? Now, if you want to spend more time to think about this, pause the video. And, it's actually very useful to think about that. As I said, it's a real decision that you have to make, if you are building your own search engine, or if you're working, for a company that, cares about the search. Now, if you have thought about this for a moment, you might realize that, well, in this case, it's hard to say. Now, some users might like a system A, some users might like, like system B. So, what's the difference here? Well, the difference is just that, you know, in the, low level of recall, in this region, system B is better. There's a higher precision. But in high recall region, system A is better. Now, so, that also means, it depends on whether the user cares about the high recall, or low recall, but high precision. You can imagine, if someone is just going to check out, what's happening today, and want to find out something relevant in the news. Well, which one is better? What do you think? In this case, clearly, system B is better, because the user is unlikely examining a lot of results. The user doesn't care about high recall. On the other hand, if you think about a case, where a user is doing you are, starting a problem. You want to find, whether your idea ha, has been started before. In that case, you emphasize high recall. So, you want to see, as many relevant documents as possible. Therefore, you might, favor, system A. So, that means, which one is better? That actually depends on users, and more precisely, users task. So, this means, you may not necessarily be able to come up with one number, that would accurately depict the performance. You have to look at the overall picture. Yet, as I said, when you have a practical decision to make, whether you replace ours with another, then you may have to actually come up with a single number, to quantify each, method. Or, when we compare many different methods in research, ideally, we have one number to compare, them with, so, that we can easily make a lot of comparisons. So, for all these reasons, it is desirable to have one, single number to match it up. So, how do we do that? And, that, needs a number to summarize the range. So, here again it's the precision-recall curve, right? And, one way to summarize this whole ranked, list, for this whole curve, is look at the area underneath the curve. Right? So, this is one way to measure that. There are other ways to measure that, but, it just turns out that,, this particular way of matching it has been very, popular, and has been used, since a long time ago for text And, this is, basically, in this way, and it's called the average precision. Basically, we're going to take a, a look at the, every different, recall point. And then, look out for the precision. So, we know, you know, this is one precision. And, this is another, with, different recall. Now, this, we don't count to this one, because the recall level is the same, and we're going to, look at the, this number, and that's precision at a different recall level et cetera. So, we have all these, you know, added up. These are the precisions at the different points, corresponding to retrieving the first relevant document, the second, and then, the third, that follows, et cetera. Now, we missed the many relevant documents, so, in all of those cases, we just, assume, that they have zero precisions. And then, finally, we take the average. So, we divide it by ten, and which is the total number of relevant documents in the collection. Note that here, we're not dividing this sum by four. Which is a number retrieved relevant documents. Now, imagine, if I divide by four, what would happen? Now, think about this, for a moment. It's a common mistake that people, sometimes, overlook. Right, so, if we, we divide this by four, it's actually not very good. In fact, that you are favoring a system, that would retrieve very few random documents, as in that case, the denominator would be very small. So, this would be, not a good matching. So, note that this denomina, denominator is ten, the total number of relevant documents. And, this will basically ,compute the area, and the needs occur. And, this is the standard method, used for evaluating a ranked list. Note that, it actually combines recall and, precision. But first, you know, we have precision numbers here, but secondly, we also consider recall, because if missed many, there would be many zeros here. All right, so, it combines precision and recall. And furthermore, you can see this measure is sensitive to a small change of a position of a relevant document. Let's say, if I move this relevant document up a little bit, now, it would increase this means, this average precision. Whereas, if I move any relevant document, down, let's say, I move this relevant document down, then it would decrease, uh,the average precision. So, this is a very good, because it's a very sensitive to the ranking of every relevant document. It can tell, small differences between two ranked lists. And, that is what we want, sometimes one algorithm only works slightly better than another. And, we want to see this difference. In contrast, if we look at the precision at the ten documents. If we look at this, this whole set, well, what, what's the precision, what do you think? Well, it's easy to see, that's a four out of ten, right? So, that precision is very meaningful, because it tells us, what user would see? So, that's pretty useful, right? So, it's a meaningful measure, from a users perspective. But, if we use this measure to compare systems, it wouldn't be good, because it wouldn't be sensitive to where these four relevant documents are ranked. If I move them around the precision at ten, still, the same. Right. So, this is not a good measure for comparing different algorithms. In contrast, the average precision is a much better measure. It can tell the difference of, different, a difference in ranked list in, subtle ways.
So average precision is computer for just one. one query. But we generally experiment with many different queries and this is to avoid the variance across queries. Depending on the queries you use you might make different conclusions. Right, so it's better then using more queries. If you use more queries then, you will also have to take the average of the average precision over all these queries. So how can we do that? Well, you can naturally. Think of just doing arithmetic mean as we always tend to, to think in, in this way. So, this would give us what's called a "Mean Average Position", or MAP. In this case, we take arithmetic mean of all the average precisions over several queries or topics. But as I just mentioned in another lecture, is this good? We call that. We talked about the different ways of combining precision and recall. And we conclude that the arithmetic mean is not as good as the MAP measure. But here it's the same. We can also think about the alternative ways of aggregating the numbers. Don't just automatically assume that, though. Let's just also take the arithmetic mean of the average position over these queries. Let's think about what's the best way of aggregating them. If you think about the different ways, naturally you will, probably be able to think about another way, which is geometric mean. And we call this kind of average a gMAP. This is another way. So now, once you think about the two different ways. Of doing the same thing. The natural question to ask is, which one is better? So. So, do you use MAP or gMAP? Again, that's important question. Imagine you are again testing a new algorithm in, by comparing the ways your old algorithms made the search engine. Now you tested multiple topics. Now you've got the average precision for these topics. Now you are thinking of looking at the overall performance. You have to take the average. But which, which strategy would you use? Now first, you should also think about the question, well did it make a difference? Can you think of scenarios where using one of them would make a difference? That is they would give different rankings of those methods. And that also means depending on the way you average or detect the. Average of these average positions. You will get different conclusions. This makes the question becoming even more important. Right? So, which one would you use? Well again, if you look at the difference between these. Different ways of aggregating the average position. You'll realize in arithmetic mean, the sum is dominating by large values. So what does large value here mean? It means the query is relatively easy. You can have a high pres, average position. Whereas gMAP tends to be affected more by low values. And those are the queries that don't have good performance. The average precision is low. So if you think about the, improving the search engine for those difficult queries, then gMAP would be preferred, right? On the other hand, if you just want to. Have improved a lot. Over all the kinds of queries or particular popular queries that might be easy and you want to make the perfect and maybe MAP would be then preferred. So again, the answer depends on your users, your users tasks and their pref, their preferences. So the point that here is to think about the multiple ways to solve the same problem, and then compare them, and think carefully about the differences. And which one makes more sense. Often, when one of them might make sense in one situation and another might make more sense in a different situation. So it's important to pick out under what situations one is preferred. As a special case of the mean average position, we can also think about the case where there was precisely one rank in the document. And this happens often, for example, in what's called a known item search. Where you know a target page, let's say you have to find Amazon, homepage. You have one relevant document there, and you hope to find it. That's call a "known item search". In that case, there's precisely one relevant document. Or in another application, like a question and answering, maybe there's only one answer. Are there. So if you rank the answers, then your goal is to rank that one particular answer on top, right? So in this case, you can easily verify the average position, will basically boil down to reciprocal rank. That is, 1 over r where r is the rank position of that single relevant document. So if that document is ranked on the very top or is 1, and then it's 1 for reciprocal rank. If it's ranked at the, the second, then it's 1 over 2. Et cetera. And then we can also take a, a average of all these average precision or reciprocal rank over a set of topics, and that would give us something called a mean reciprocal rank. It's a very popular measure. For no item search or, you know, an problem where you have just one relevant item. Now again here, you can see this r actually is meaningful here. And this r is basically indicating how much effort a user would have to make in order to find that relevant document. If it's ranked on the top it's low effort that you have to make, or little effort. But if it's ranked at 100 then you actually have to, read presumably 100 documents in order to find it. So, in this sense r is also a meaningful measure and the reciprocal rank will take the reciprocal of r, instead of using r directly. So my natural question here is why not simply using r? I imagine if you were to design a ratio to, measure the performance of a random system, when there is only one relevant item. You might have thought about using r directly as the measure. After all, that measures the user's effort, right? But, think about if you take a average of this over a large number of topics. Again it would make a difference. Right, for one single topic, using r or using 1 over r wouldn't make any difference. It's the same. Larger r with corresponds to a small 1 over r, right? But the difference would only show when, show up when you have many topics. So again, think about the average of Mean Reciprocal Rank versus average of just r. What's the difference? Do you see any difference? And would, would this difference change the oath of systems. In our conclusion. And this, it turns out that, there is actually a big difference, and if you think about it, if you want to think about it and then, yourself, then pause the video. Basically, the difference is, if you take some of our directory, then. Again it will be dominated by large values of r. So what are those values? Those are basically large values that indicate that lower ranked results. That means the relevant items rank very low down on the list. And the sum that's also the average that would then be dominated by. Where those relevant documents are ranked in, in ,in, in the lower portion of the ranked. But from a users perspective we care more about the highly ranked documents. So by taking this transformation by using reciprocal rank. Here we emphasize more on the difference on the top. You know, think about the difference between 1 and the 2, it would make a big difference, in 1 over r, but think about the 100, and 1, and where and when won't make much difference if you use this. But if you use this there will be a big difference in 100 and let's say 1,000, right. So this is not the desirable. On the other hand, a 1 and 2 won't make much difference. So this is yet another case where there may be multiple choices of doing the same thing and then you need to figure out which one makes more sense. So to summarize, we showed that the precision-recall curve. Can characterize the overall accuracy of a ranked list. And we emphasized that the actual utility of a ranked list depends on how many top ranked results a user would actually examine. Some users will examine more. Than others. An average person uses a standard measure for comparing two ranking methods. It combines precision and recall and it's sensitive to the rank of every random document.
This lecture is about how to evaluate the text retrieval system when we have multiple levels of judgements. In this lecture, we will continue the discussion of evaluation. We're going to look at how to evaluate a text retrieval system, when we have multiple levels of judgements. So far we have talked about the binary judgements, that means a document is judged as being relevant or not relevant. But earlier, we also talk about the relevance as a medal of degrees. So we often can distinguish very high relevant documents, those are very useful documents, from moderately relevant documents. They are okay, they are useful perhaps. And further from now, we're adding the documents, those are not useful. So imagine you can have ratings for these pages. Then, you would have multiple levels of ratings. For example, here I show example of three levels, 3 for relevant, sorry 3 for very relevant, 2 for marginally relevant, and 1 for non-relevant. Now, how do we evaluate the search engine system using these judgements? Obvious that the map doesn't work, average of precision doesn't work, precision, and recall doesn't work, because they rely on binary judgements. So let's look at some top ranked results when using these judgements. Imagine the user would be mostly care about the top ten results here. And we marked the rating levels, or relevance levels, for these documents as shown here, 3, 2, 1, 1, 3, etcetera. And we call these gain. And the reason why we call it the gain is because the measure that we are infusing is called the NDCG normalized or accumulated gain. So this gain, basically, can measure how much a gain of random information a user can obtain by looking at each document, right? So looking at the first document, the user can gain 3 points. Looking at the non-relevant document user would only gain 1 point. Looking at the moderator or marginally relevant, document the user would get 2 points, etcetera. So, this gain to each of the measures is a utility of the document from a user's perspective. Of course, if we assume the user stops at the 10 documents and we're looking at the cutoff at 10, we can look at the total gain of the user. And what's that? Well, that's simply the sum of these, and we call it the Cumulative Gain. So if the user stops after the position 1, that's just a 3. If the user looks at another document, that's a 3+2. If the user looks at the more documents, then the cumulative gain is more. Of course this is at the cost of spending more time to examine the list. So cumulative gain gives us some idea about how much total gain the user would have if the user examines all these documents. Now, in NDCG, we also have another letter here, D, discounted cumulative gain. So, why do we want to do discounting? Well, if you look at this cumulative gain, there is one deficiency, which is it did not consider the rank position of these documents. So for example, looking at this sum here, and we only know there is 1 highly relevant document, 1 marginally relevant document, 2 non-relevant documents. We don't really care where they are ranked. Ideally, we want these two to be ranked on the top which is the case here. But how can we capture that intuition? Well we have to say, well this is 3 here is not as good as this 3 on the top. And that means the contribution of the gain from different positions has to be weighted by their position. And this is the idea of discounting, basically. So we're going to to say, well, the first one does not need to be discounted because the user can be assumed that will always see this document. But the second one, this one will be discounted a little bit because there's a small possibility that the user wouldn't notice it. So we divide this gain by a weight based on the position. So log of 2, 2 is the rank position of this document. And when we go to the third position, we discounted even more, because the normalizer is log of 3, and so on and so forth. So when we take such a sum that a lower ranked document would not contribute that much as a highly ranked document. So that means if you, for example, switch the position of this, let's say this position, and this one, and then you would get more discount if you put, for example very relevant document here as opposed to here. Imagine if you put the 3 here, then it would have to be discounted. So it's not as good as if you we would put the 3 here. So this is the idea of discounting. Okay, so now at this point that we have got a discounted cumulative gain for measuring the utility of this ranked list with multiple levels of judgements. So are we happy with this? Well, we can use this to rank systems. Now, we still need to do a little bit more in order to make this measure comparable across different topics. And this is the last step, and by the way, here we just show the DCG at 10, so this is the total sum of DCG, all these 10 documents. So the last step is called N, normalization. And if we do that, then we'll get the normalized DCG. So how do we do that? Well, the idea here is we're going to normalize DCG by the ideal DCG at the same cutoff. What is the ideal DCG? Well, this is the DCG of an ideal ranking. So imagine if we have 9 documents in the whole collection rated 3 here. And that means in total we have 9 documents rated 3. Then our ideal rank lister would have put all these 9 documents on the very top. So all these would have to be 3 and then this would be followed by a 2 here. Because that's the best we could do after we have run out of the 3. But all these positions would be 3. Right? So this would our ideal ranked list. And then we had computed the DCG for this ideal rank list. So this would be given by this formula that you see here. And so this ideal DCG would then be used as the normalizer DCG. So here. And this idea of DCG would be used as a normalizer. So you can imagine now, normalization essentially is to compare the actual DCG with the best DCG you can possibly get for this topic. Now why do we want to do this? Well, by doing this we'll map the DCG values into a range of 0 through 1. So the best value, or the highest value, for every query would be 1. That's when your rank list is, in fact, the ideal list but otherwise, in general, you will be lower than one. Now, what if we don't do that? Well, you can see, this transformation, or this normalization, doesn't really affect the relative comparison of systems for just one topic, because this ideal DCG is the same for all the systems, so the ranking of systems based on only DCG would be exactly the same as if you rank them based on the normalized DCG. The difference however is when we have multiple topics. Because if we don't do normalization, different topics will have different scales of DCG. For a topic like this one, we have 9 highly relevant documents, the DCG can get really high, but imagine in another case, there are only two very relevant documents in total in the whole collection. Then the highest DCG that any system could achieve for such a topic would not be very high. So again, we face the problem of different scales of DCG values. When we take an average, we don't want the average to be dominated by those high values. Those are, again, easy queries. So, by doing the normalization, we can have avoided the problem, making all the queries contribute to equal to the average. So, this is a idea of NDCG, it's used for measuring a rank list based on multiple level of relevance judgements. In a more general way this is basically a measure that can be applied to any ranked task with multiple level of judgements. And the scale of the judgements can be multiple, can be more than binary not only more than binary they can be much multiple levels like 1, 0, 5 or even more depending on your application. And the main idea of this measure, just to summarize, is to measure the total utility of the top k documents. So you always choose a cutoff and then you measure the total utility. And it would discount the contribution from a lowly ranked document. And then finally, it would do normalization to ensure comparability across queries.
This lecture is about some practical issues that you would have to address in evaluation of text retrieval systems. In this lecture, we will continue the discussion of evaluation. We'll cover some practical issues that you have to solve in actual evaluation of text retrieval systems. So, in order to create the test collection, we have to create a set of queries. A set of documents and a set of relevance judgments. It turns out that each is actually challenging to create. First, the documents and queries must be representative. They must represent the real queries and real documents that the users handle. And we also have to use many queries and many documents in order to avoid a bias of conclusions. For the matching of relevant documents with the queries. We also need to ensure that there exists a lot of relevant documents for each query. If a query has only one, that's a relevant option we can actually then. It's not very informative to compare different methods using such a query because there's not that much room for us to see difference. So ideally, there should be more relevant documents in the clatch but yet the queries also should represent the real queries that we care about. In terms of relevance judgments, the challenge is to ensure complete judgments of all the documents for all the queries. Yet, minimizing human and fault, because we have to use human labor to label these documents. It's very labor intensive. And as a result, it's impossible to actually label all the documents for all the queries, especially considering a giant data set like the web. So this is actually a major challenge, it's a very difficult challenge. For measures, it's also challenging, because we want measures that would accurately reflect the perceived utility of users. We have to consider carefully what the users care about. And then design measures to measure that. If your measure is not measuring the right thing, then your conclusion would be misled. So it's very important. So we're going to talk about a couple of issues here. One is the statistical significance test. And this also is a reason why we have to use a lot of queries. And the question here is how sure can you be that observe the difference doesn't simply result from the particular queries you choose. So here are some sample results of average position for System A and System B into different experiments. And you can see in the bottom, we have mean average of position. So the mean, if you look at the mean average of position, the mean average of positions are exactly the same in both experiments, right? So you can see this is 0.20, this is 0.40 for System B. And again here it's also 0.20 and 0.40, so they are identical. Yet, if you look at these exact average positions for different queries. If you look at these numbers in detail, you would realize that in one case, you would feel that you can trust the conclusion here given by the average. In the another case, in the other case, you will feel that, well, I'm not sure. So, why don't you take a look at all these numbers for a moment, pause the media. So, if you look at the average, the mean average of position, we can easily, say that well, System B is better, right? So, after all it's 0.40 and this is twice as much as 0.20, so that's a better performance. But if you look at these two experiments, look at the detailed results. You will see that, we've been more confident to say that, in the case one, in experiment one. In this case. Because these numbers seem to be consistently better for System B. Whereas in Experiment 2, we're not sure because looking at some results like this, after System A is better and this is another case System A is better. But yet if we look at only average, System B is better. So, what do you think? How reliable is our conclusion, if we only look at the average? Now in this case, intuitively, we feel Experiment 1 is more reliable. But how can we quantitate the answer to this question? And this is why we need to do statistical significance test. So, the idea of the statistical significance test is basically to assess the variants across these different queries. If there is a big variance, that means the results could fluctuate a lot according to different queries. Then we should believe that, unless you have used a lot of queries, the results might change if we use another set of queries. Right, so this is then not so if you have c high variance then it's not very reliable. So let's look at these results again in the second case. So, here we show two different ways to compare them. One is a sign test where we just look at the sign. If System B is better than System A, we have a plus sign. When System A is better we have a minus sign, etc. Using this case, if you see this, well, there are seven cases. We actually have four cases where System B is better. But three cases of System A is better, intuitively, this is almost like a random results, right? So if you just take a random sample of you flip seven coins and if you use plus to denote the head and minus to denote the tail and that could easily be the results of just randomly flipping these seven coins. So, the fact that the average is larger doesn't tell us anything. We can't reliably conclude that. And this can be quantitatively measured by a p value. And that basically means the probability that this result is in fact from a random fluctuation. In this case, probability is 1.0. It means it surely is a random fluctuation. Now in Willcoxan test, it's a non-parametric test, and we would be not only looking at the signs, we'll be also looking at the magnitude of the difference. But we can draw a similar conclusion, where you say it's very likely to be from random. To illustrate this, let's think about that such a distribution. And this is called a now distribution. We assume that the mean is zero here. Lets say we started with assumption that there's no difference between the two systems. But we assume that because of random fluctuations depending on the queries, we might observe a difference. So the actual difference might be on the left side here or on the right side here, right? So, and this curve kind of shows the probability that we will actually observe values that are deviating from zero here. Now, so if we look at this picture then, we see that if a difference is observed here, then the chance is very high that this is in fact a random observation, right? We can define a region of likely observation because of random fluctuation and this is that 95% of all the outcomes. And in this then the observed may still be from random fluctuation. But if you observe a value in this region or a difference on this side, then the difference is unlikely from random fluctuation. All right, so there's a very small probability that you are observe such a difference just because of random fluctuation. So in that case, we can then conclude the difference must be real. So System B is indeed better. So this is the idea of Statical Significance Test. The takeaway message here is that you have to use many queries to avoid jumping into a conclusion. As in this case, to say System B is better. There are many different ways of doing this Statistical Significance Test. So now, let's talk about the other problem of making judgments and, as we said earlier, it's very hard to judge all the documents completely unless it's a very small data set. So the question is, if we can afford judging all the documents in the collection, which is subset should we judge? And the solution here is Pooling. And this is a strategy that has been used in many cases to solve this problem. So the idea of Pooling is the following. We would first choose a diverse set of ranking methods. These are Text Retrieval systems. And we hope these methods can help us nominate like the relevant documents. So the goal is to pick out the relevant documents. We want to make judgements on relevant documents because those are the most useful documents from users perspectives. So then we're going to have each to return top-K documents. The K can vary from systems. But the point is to ask them to suggest the most likely relevant documents. And then we simply combine all these top-K sets to form a pool of documents for human assessors. To judge, so imagine you have many systems each were ten k documents. We take the top-K documents, and we form a union. Now, of course, there are many documents that are duplicated because many systems might have retrieved the same random documents. So there will be some duplicate documents. And there are also unique documents that are only returned by one system. So the idea of having diverse set of ranking methods is to ensure the pool is broad. And can include as many possible relevant documents as possible. And then, the users would, human assessors would make complete the judgments on this data set, this pool. And the other unjudged the documents are usually just assumed to be non relevant. Now if the pool is large enough, this assumption is okay. But if the pool is not very large, this actually has to be reconsidered. And we might use other strategies to deal with them and there are indeed other methods to handle such cases. And such a strategy is generally okay for comparing systems that contribute to the pool. That means if you participate in contributing to the pool, then it's unlikely that it would penalize your system because the problematic documents have all been judged. However, this is problematic for evaluating a new system that may have not contributed to the pool. In this case, a new system might be penalized because it might have nominated some read only documents that have not been judged. So those documents might be assumed to be non relevant. That's unfair. So to summarize the whole part of textual evaluation, it's extremely important. Because the problem is the empirically defined problem, if we don't rely on users, there's no way to tell whether one method works better. If we have in the property experiment design, we might misguide our research or applications. And we might just draw wrong conclusions. And we have seen this is in some of our discussions. So make sure to get it right for your research or application. The main methodology is the Cranfield evaluation methodology. And they are the main paradigm used in all kinds of empirical evaluation tasks, not just a search engine variation. Map and nDCG are the two main measures that you should definitely know about and they are appropriate for comparing ranking algorithms. You will see them often in research papers. Precision at 10 documents is easier to interpret from user's perspective. So that's also often useful. What's not covered is some other evaluation strategy like A-B Test. Where the system would mix two, the results of two methods, randomly. And then would show the mixed results to users. Of course, the users don't see which result, from which method. The users would judge those results or click on those documents in a search engine application. In this case then, the search engine can check or click the documents and see if one method has contributed more through the click the documents. If the user tends to click on one, the results from one method, then it suggests that message may be better. So this is what leverages the real users of a search engine to do evaluation. It's called A-B Test and it's a strategy that is often used by the modern search engines or commercial search engines. Another way to evaluate IR or textual retrieval is user studies and we haven't covered that. I've put some references here that you can look at if you want to know more about that. So, there are three additional readings here. These are three mini books about evaluation and they are all excellent in covering a broad review of Information Retrieval Evaluation. And it covers some of the things that we discussed, but they also have a lot of others to offer.
